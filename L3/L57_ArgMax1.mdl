$BC55MODEL
#substlang "English"
|Автоматически генерируемая модель полуавтокомпилируемого внутреннего максимизатора
>English
|Automatically generated model of user-defined function maximizer
$NOSHARE
$VARS
  signal name "_Start" in run default 1
  signal name "_Ready" out default 0
  short name "Aux_in" in hide default 0
  short name "Aux_out" out hide default 0
  signal name "Start_cmd" in menu run default 0
  signal name "Restart_cmd" in menu run default 0
  matrix logical oneindex name "Enabled_in" in run default "[ ] 0"
  signal name "_Enabled_chg" default 1
  int name "_Stage" out default 0
  int name "_SubStage" out default 0
  logical name "_results_ok" default 0
  logical name "_enabled_res" default 1
  logical name "Complete_out" out default 0
  logical name "Error_out" out default 0
  signal name "Finished_out" out default 0
  signal name "Started_out" out default 0
  double name "Time_out" out default "?"
  char name "Func_in" in menu default ""
  char name "Func_out" out menu default ""
  signal name "_allinval_dchg" default 1
  double name "L0" in menu run default "0"
  double name "C0" in menu run default ""
  matrix double name "argmax_func" out menu default "[ ] ?"
  matrix double name "AllMax_out" out default "[ ] ?"
  double name "Progress_out" out default "0"
  matrix double oneindex name "Y_res" out menu default "[ ] ?"
  double name "Y_res_f" out default "?"
  matrix double oneindex name "L_res" out menu default "[ ] ?"
  double name "L_res_f" out default "?"
  matrix double oneindex name "r_res" out menu default "[ ] ?"
  double name "r_res_f" out default "?"
  matrix double oneindex name "_max_res" out menu default "[ ] ?"
  double name "_max_res_f" out default "?"

$AUTO
  "Enabled_in","_Enabled_chg"
  "AllMax_out","_results_ok"
  "Complete_out","_results_ok"
  "Error_out","_results_ok"
    "L0","_allinval_dchg"
    "C0","_allinval_dchg"
  "argmax_func","_results_ok"
  "Y_res","_results_ok"
  "Y_res_f","_results_ok"
  "L_res","_results_ok"
  "L_res_f","_results_ok"
  "r_res","_results_ok"
  "r_res_f","_results_ok"
  "_max_res","_results_ok"
  "_max_res_f","_results_ok"

$PARAM
  BOOL name "deepsearch_setup" default "FALSE"
  BOOL name "noautostart_setup" default "FALSE"
  double name "ChunkSizeMb_setup" default "4"
  int name "tactcount_setup" default "1000"
  double name "EqualMaxDelta_setup" default "0.001"
  BOOL name "PrecToEndSteps_setup" default "TRUE"
  BOOL name "PrecToDf_setup" default "TRUE"
  int name "DfCycles_setup" default "5"
  double name "DfDelta_setup" default "0.00001"
  int name "PrecGridSize_setup" default "0"
  BOOL name "NoPlateau_setup" default "FALSE"
  BOOL name "TabAfterCalc_setup" default "TRUE"
  BOOL name "TabPrecCalc_setup" default "TRUE"
  BOOL name "Tab_PrecToEndSteps_setup" default "TRUE"
  BOOL name "Tab_PrecToDf_setup" default "TRUE"
  int name "Tab_DfCycles_setup" default "5"
  double name "Tab_DfDelta_setup" default "0.00001"
  int name "Tab_PrecGridSize_setup" default "0"
  double name "DfFilter_setup" default "0.00001"
  int name "TR_params" default "0"
  rdsbcppString name "TR_text" default "" notranslate
  int name "StartCycles_setup" default "20"
$REGFUN
  name "IPU.L57.UserFuncTransfer.IsFuncSource" id "L57_BlkFunc_IsFuncSource"
  name "IPU.L57.UserFuncTransfer.AcceptFunction" id "L57_BlkFunc_AcceptFunc" param "L57_AcceptFunc_Param*"
  name "IPU.L57.UserFuncTransfer.AcceptParameter" id "L57_BlkFunc_AcceptParam" param "L57_AcceptParam_Param*"
  name "IPU.L57.UserFuncTransfer.IsParameterTransferredWithFunc" id "L57_BlkFunc_CheckTransParam" param "L57_CheckParamConn_Param*"
  name "IPU.L57.UserFuncTransfer.CheckParamTransfer" id "L57_BlkFunc_CheckTransParam2" param "L57_CheckTranser_Param*"
$LINKS
  manual "$RDSINCLUDE$\RdsL57Mk2\L57Mk2ArgMax.cpp"
  manual "$RDSINCLUDE$\RdsL57Mk2\L57Mk2Basic.cpp"
  manual "$RDSINCLUDE$\RdsL57Mk2\L57Mk2Basic.h"
  manual "$RDSINCLUDE$\RdsL57Mk2\L57Mk2Bits.cpp"
$CUSTOMERR
|В одном из описаний функций обнаружена ошибка: видимо, текст функции написан не в синтаксисе языка C. Пожалуйста, проверьте все описания в настройках блока или откройте редактор модели и изучите ошибки, выданные компилятором.
$STRINGS
  id "L57_MSGCAPTION" text "Внутренний максимизатор" lf bin "$CURLANG$\Dll\L57.bin" "SemiAutoArgMax" "ModelMessagesCaption"
$ENDDECL
$GLOBAL
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически
   ATTENTION! This model is generated automatically, do not edit it */



































// Версия модели (в норме должна соответствовать L57_LATESTMODELVERSION)
#define L57_MODELVERSION 15

// Число максимизируемых параметров
#define L57_PARAMSCOUNT 3

// Файл и тема справки
#define L57_HELPUIFILE "Blocks\\L57.ui"
#define L57_HELPTOPIC "L57Mk2ArgMax"

// Заголовки функций для индикации
#define L57_TITLES ""
// Тела функций для индикации
#define L57_PROGRAMS "return(L-L0)*Y-Y*Y/(2*r) - C0;"

// Число простых выходных таблиц F(x)
#define L57_ONEARG_SIMPLE_CNT 0
// Число простых выходных таблиц F(x,y)
#define L57_TWOARG_SIMPLE_CNT 0
// Число выходных таблиц ArgMax(x)
#define L57_ONEARG_ARGMAX_CNT 0
// Число выходных таблиц ArgMax(x,y)
#define L57_TWOARG_ARGMAX_CNT 1

// Определены конечные шаги
#define L57_ENDSTEPSUSED

#define L57MS_GLOBALS
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_GLOBALS


// Служебный класс для вычисления значения функции
#define ERRORVALUE (L57_ERROR())
#define L57_CALCCLASSNAME L57_Calc
#define L57_CALCTYPE_VALUE
class L57_Calc
{
  public:
    inline double L57_ERROR(void){return rdsbcppHugeDouble;};
    double Y;
    double L;
    double r;
    double L0;
    double C0;
    // Функция вычисления (генерируемая)
    double _Calc_gen(void);
    // Функция вычисления double (с перехватом исключений)
    double _Calc_main(void)
    { double __temp;
      RDSBCPP_TRY
        { __temp=_Calc_gen(); }
      RDSBCPP_CATCHALL
        { __temp=rdsbcppHugeDouble; }
      return __temp;
    };
    // Функция вычисления исходного типа (с перехватом исключений)
    double _Calc_original(void)
{ return _Calc_main(); };
};
// Функция вычисления (генерируемая)
double L57_Calc::_Calc_gen(void)
{
  #define L57_ORIGPARAM(x) (L57_CALCCLASSNAME::x)
  #ifndef BCPP55_ERRORRETRYCOMPILE
return(L-L0)*Y-Y*Y/(2*r) - C0;
  #endif // ifndef BCPP55_ERRORRETRYCOMPILE
; /* */
  return rdsbcppHugeDouble;
  #undef L57_ORIGPARAM
}
#undef L57_CALCCLASSNAME
#undef ERRORVALUE
//----------------------------------------------------------------------

$MODEL
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_MODEL
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_MODEL

$SETUP
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_SETUP
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_SETUP

$CLASSDEF
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_CLASS
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_CLASS

  // Фиксированные значения границ и шагов
    double Y_0;
    double Y_min;
    double Y_max;
    double Y_step;
    double Y_end;
    double L_0;
    double L_min;
    double L_max;
    double L_step;
    double L_end;
    double r_0;
    double r_min;
    double r_max;
    double r_step;
    double r_end;
  // Инициализация фиксированных значений
  void L57_Init_Fixed_Data(void);

  // Объекты для передачи входов-параметров функции
  L57_FuncTransfer _Transfer;
  L57_FuncTransferParameter *L0_trans;
  L57_FuncTransferParameter *C0_trans;
  // Сброс
  void L57_Reset_Trans_Data(void)
  {
    L0_trans=NULL;
    C0_trans=NULL;
  };
  // Создание всех параметров передачи
  void L57_Create_Trans_Data(void);

  // Хранилища для проверки изменения переменных
  double L0_old;
  double C0_old;
  // Инициализация хранилищ значений
  void L57_Init_Old_Data(void)
  {
    L0_old=rdsbcppHugeDouble;
    C0_old=rdsbcppHugeDouble;
  };

  // Выходные таблицы argmax(x,y)
  L57_Table2ArgFuncData _TwoargArgMaxF[L57_TWOARG_ARGMAX_CNT];


$CLASSEXT
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_AFTERCLASS
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_AFTERCLASS

// Экспорт текста функции для взаимодействия с другими блоками по связям
char *rdsbcppBlockClass::_FuncExportText="V C0 V \n"
"V L V 0\n"
"V L0 V 0\n"
"V r V 0\n"
"V Y V 0\n"
"F\n"
"T\n"
"X\n"
"|return(L-L0)*Y-Y*Y/(2*r) - C0;\n"
"}\n"
"#ORDER#\n"
"Y\n"
"L\n"
"r\n"
"L0\n"
"C0";

// Инициализация фиксированных значений
void rdsbcppBlockClass::L57_Init_Fixed_Data(void)
{
    Y_0=0;
    Y_min=0;
    Y_max=50;
    Y_step=0.1;
    Y_end=0.01;
    L_0=0;
    L_min=0;
    L_max=15;
    L_step=0.1;
    L_end=0.01;
    r_0=0;
    r_min=0.1;
    r_max=5;
    r_step=0.1;
    r_end=0.01;

}
//-----------------------------------------------------------------------

// Создание всех параметров передачи
void rdsbcppBlockClass::L57_Create_Trans_Data(void)
{
  // Стационарных входов: 2
  // Максимизируемых параметров: 3
  _Transfer.ClearParameters();
  _Transfer.EnlargeParameters(2+3*5);

  L0_trans=_Transfer.AddParameterRds("L0",L57_VARSUFFIX_NONE,FALSE,L0.Num(),&L0);
  C0_trans=_Transfer.AddParameterRds("C0",L57_VARSUFFIX_NONE,FALSE,C0.Num(),&C0);

  _Transfer.AddParameter("Y",L57_VARSUFFIX_0,FALSE,-1,&Y_0);
  _Transfer.AddParameter("Y",L57_VARSUFFIX_MIN,FALSE,-1,&Y_min);
  _Transfer.AddParameter("Y",L57_VARSUFFIX_MAX,FALSE,-1,&Y_max);
  _Transfer.AddParameter("Y",L57_VARSUFFIX_STEP,FALSE,-1,&Y_step);
  _Transfer.AddParameter("Y",L57_VARSUFFIX_END,FALSE,-1,&Y_end);

  _Transfer.AddParameter("L",L57_VARSUFFIX_0,FALSE,-1,&L_0);
  _Transfer.AddParameter("L",L57_VARSUFFIX_MIN,FALSE,-1,&L_min);
  _Transfer.AddParameter("L",L57_VARSUFFIX_MAX,FALSE,-1,&L_max);
  _Transfer.AddParameter("L",L57_VARSUFFIX_STEP,FALSE,-1,&L_step);
  _Transfer.AddParameter("L",L57_VARSUFFIX_END,FALSE,-1,&L_end);

  _Transfer.AddParameter("r",L57_VARSUFFIX_0,FALSE,-1,&r_0);
  _Transfer.AddParameter("r",L57_VARSUFFIX_MIN,FALSE,-1,&r_min);
  _Transfer.AddParameter("r",L57_VARSUFFIX_MAX,FALSE,-1,&r_max);
  _Transfer.AddParameter("r",L57_VARSUFFIX_STEP,FALSE,-1,&r_step);
  _Transfer.AddParameter("r",L57_VARSUFFIX_END,FALSE,-1,&r_end);

}
//-----------------------------------------------------------------------

// Проверка изменения переменных
// *pChgSignalOn взводится при наличии сигнала изменения (независимо от фактического изменения)
BOOL rdsbcppBlockClass::L57InputsChange(BOOL _force,BOOL *pChgSignalOn)
{ BOOL _changes=FALSE;

  // Стационарных вещественных входов: 2
  // Служебных вещественных входов: 0
  // Итого вещественных: 2

  // Вещественные входы
  if(_allinval_dchg!=0 || _force)
    { _allinval_dchg=0;
      _changes=_force;
      if(pChgSignalOn) *pChgSignalOn=TRUE;

      if(L0_old!=L0)
        { _changes=TRUE;
          _Transfer.TransferParameter(rdsbcppBlockData->Block,L0_trans,_Transfer.DestBlocks,TRUE);
        }
      if(C0_old!=C0)
        { _changes=TRUE;
          _Transfer.TransferParameter(rdsbcppBlockData->Block,C0_trans,_Transfer.DestBlocks,TRUE);
        }


      if(_changes)
        { // Запоминание изменившихся
          L0_old=L0;
          C0_old=C0;
        }
    }

  // Матричные входы (матрицы, массивы, функции)

  return _changes;
}
//-----------------------------------------------------------------------

// Занесение стационарных переменных в вычислитель функции
void rdsbcppBlockClass::L57InputsToCalc(void)
{
  _Calculator.L0=L0;
  _Calculator.C0=C0;
}
//-----------------------------------------------------------------------

// Инициализация набора максимизируемых параметров
void rdsbcppBlockClass::L57InitParams(void)
{
  _Params.P[0].FuncVal=Y_0; // 0
  _Params.P[0].Min=Y_min; // 0
  _Params.P[0].Max=Y_max; // 50
  _Params.P[0].StartStep=Y_step; // 0.1
  _Params.P[0].EndStep=Y_end; // 0.01

  _Params.P[1].FuncVal=L_0; // 0
  _Params.P[1].Min=L_min; // 0
  _Params.P[1].Max=L_max; // 15
  _Params.P[1].StartStep=L_step; // 0.1
  _Params.P[1].EndStep=L_end; // 0.01

  _Params.P[2].FuncVal=r_0; // 0
  _Params.P[2].Min=r_min; // 0.1
  _Params.P[2].Max=r_max; // 5
  _Params.P[2].StartStep=r_step; // 0.1
  _Params.P[2].EndStep=r_end; // 0.01

}
//-----------------------------------------------------------------------

// Занесение текущих значений параметров в вычислитель функции
void rdsbcppBlockClass::L57ParamsToCalc(void)
{
  _Calculator.Y=_Params.P[0].Current;
  _Calculator.L=_Params.P[1].Current;
  _Calculator.r=_Params.P[2].Current;
}
//-----------------------------------------------------------------------

// Установить готовность всех простых табличных функций
void rdsbcppBlockClass::_SetAllSimpleTableFuncReady(char flag)
{
}
//-----------------------------------------------------------------------

// Очистить выходные матрицы всех табличных функций
void rdsbcppBlockClass::_ClearAllTableFunc(void)
{
  argmax_func.Resize(0,0);
}
//-----------------------------------------------------------------------




// Заполнение массива генерации выходных таблиц argmax(x,y)
BOOL rdsbcppBlockClass::_TwoargArgMaxF_fill(void)
{ L57_Table2ArgFuncData *f;
  L57_Parameter *p1,*p2;

  f=_TwoargArgMaxF+0;
  p1=_Params.P+1; // L
  p2=_Params.P+2; // r
    f->Args1Array=&(p1->Array);
    f->Arg1Index=1; // L
    f->Args2Array=&(p2->Array);
    f->Arg2Index=2; // r
    f->NResults=3+1; // Значения всех аргументов и самой функции
    if(!f->AllocateResultArrays()) return FALSE;
      // Выходная матрица argmax_func
      f->Output.Add2Arg(&argmax_func,NULL,3,0); // L57_ERROR()

  return TRUE;
}
//-----------------------------------------------------------------------

// Переписать максимумы из AllMax_out в отдельные массивы (генерируется)
BOOL rdsbcppBlockClass::L57AllMaxToArrays(void)
{
#ifdef L57_PARAMSCOUNT
  int n_max=AllMax_out.Rows();
  // Аргументы
  if(!Y_res.Resize(n_max))
    return FALSE;
  for(int i=0;i<n_max;i++)
    Y_res[i]=AllMax_out[i][0];
  if(!L_res.Resize(n_max))
    return FALSE;
  for(int i=0;i<n_max;i++)
    L_res[i]=AllMax_out[i][1];
  if(!r_res.Resize(n_max))
    return FALSE;
  for(int i=0;i<n_max;i++)
    r_res[i]=AllMax_out[i][2];

  // Значения
  if(!_max_res.Resize(n_max))
    return FALSE;
  for(int i=0;i<n_max;i++)
    _max_res[i]=AllMax_out[i][L57_PARAMSCOUNT];

  // Фильтрованные данные
  if(n_max)
    { BOOL _fchg=FALSE;
      double _v,_vn;
      if(!_fchg)
        { _v=Y_res_f;
          _vn=Y_res[0];
          if(_v==rdsbcppHugeDouble || (_vn!=rdsbcppHugeDouble && fabs(_v-_vn)>_Params.P[0].EndStep*1.1) )
            _fchg=TRUE;
        }
      if(!_fchg)
        { _v=L_res_f;
          _vn=L_res[0];
          if(_v==rdsbcppHugeDouble || (_vn!=rdsbcppHugeDouble && fabs(_v-_vn)>_Params.P[1].EndStep*1.1) )
            _fchg=TRUE;
        }
      if(!_fchg)
        { _v=r_res_f;
          _vn=r_res[0];
          if(_v==rdsbcppHugeDouble || (_vn!=rdsbcppHugeDouble && fabs(_v-_vn)>_Params.P[2].EndStep*1.1) )
            _fchg=TRUE;
        }
      if((!_fchg) && DfFilter_setup!=rdsbcppHugeDouble)
        { _v=_max_res_f;
          _vn=_max_res[0];
          if(_v==rdsbcppHugeDouble || (_vn!=rdsbcppHugeDouble && fabs(_v-_vn)>DfFilter_setup) )
            _fchg=TRUE;
        }

      if(_fchg)
        {
          Y_res_f=Y_res[0];
          L_res_f=L_res[0];
          r_res_f=r_res[0];
          _max_res_f=_max_res[0];
        }
    }
#endif // ifdef L57_PARAMSCOUNT

  return TRUE;
}
//-----------------------------------------------------------------------


$INIT
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_INIT
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_INIT

$START
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_START
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_START

$CALCMODE
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_CALCMODE
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_CALCMODE

$LOADTEXT
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_LOADPARAMS
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_LOADPARAMS
$SAVETEXT
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_SAVEPARAMS
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_SAVEPARAMS

$OTHER
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_OTHER
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_OTHER

$FUNC "IPU.L57.UserFuncTransfer.IsFuncSource"
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

Result=1;

$FUNC "IPU.L57.UserFuncTransfer.AcceptFunction"
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_ACCEPTFUNC
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_ACCEPTFUNC

$FUNC "IPU.L57.UserFuncTransfer.AcceptParameter"
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_ACCEPTPARAM
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_ACCEPTPARAM

$FUNC "IPU.L57.UserFuncTransfer.IsParameterTransferredWithFunc"
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_CHECKTRANSFUNC
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_CHECKTRANSFUNC


$FUNC "IPU.L57.UserFuncTransfer.CheckParamTransfer"
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_CHECKTRANSFUNC2
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_CHECKTRANSFUNC2


$RESET
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_RESET
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_RESET


$VARCHECK
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_VARCHECK
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_VARCHECK

$DRAWADD
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_DRAWADDITIONAL
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_DRAWADDITIONAL

$HINT
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_HINT
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_HINT

$POPUP
/* ВНИМАНИЕ! Эта модель не предназначена для редактирования пользователем,
ее текст генерируется автоматически */

#define L57MS_POPUP
#include <RdsL57Mk2/L57Mk2ArgMax.cpp>
#undef L57MS_POPUP


$HIDDEN
{N
 W64,64,64,64,64
 {V
  NY
  TV
  V=0
  [=0
  ]=50
  D=0.1
  E=0.01
 }
 {V
  NL
  TV
  V=0
  [=0
  ]=15
  D=0.1
  E=0.01
 }
 {V
  Nr
  TV
  V=0
  [=0.1
  ]=5
  D=0.1
  E=0.01
 }
}
{I
 W64,64,64
 {V
  NL0
  TV
  V=0
 }
 {V
  NC0
  TV
  V=
 }
}
{F
 {F0
  T
  V
  I0
  C
  |return(L-L0)*Y-Y*Y/(2*r) - C0;
 }
}
{T
 W81,93,78,76
 {F
  Nargmax
  Tmax
  AL,r
  R%0
 }
}
{O
 :EndStep=1
}
$OPTIONS
  tabs $GLOBAL
  window pos 18 164 size 1214 837 hdiv 337 vdiv 356 fdiv 334 hidevar
  svc 0 90 1 73 2 90 3 90
  dvc 0 90 1 90 2 90
  fnc 0 90 1 90 2 90
  pvc 0 90 1 90 2 100
  dvcheck 1
  indexcheck 0
  ignorewarnings 1
  errorretrycompile 1
  customerrmsg 1 showblock
  customerrtransl "$CURLANG$\Dll\L57.bin" "L57mdl" "CustomErrSingleFunc"
  autoreadonlyeditor 1
  genvartypemacros 0
  matherr 1
  catchall 0
  dvstart 1
  searchlinks off
  undefvars 1

